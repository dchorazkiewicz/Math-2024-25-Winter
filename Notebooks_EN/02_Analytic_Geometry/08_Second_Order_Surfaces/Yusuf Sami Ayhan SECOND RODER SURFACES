#EX1 
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Center and radius of the sphere
center = np.array([1, 2, 3])
radius = 3

# Create a meshgrid for spherical coordinates
u = np.linspace(0, 2 * np.pi, 100)
v = np.linspace(0, np.pi, 100)
x = center[0] + radius * np.outer(np.cos(u), np.sin(v))
y = center[1] + radius * np.outer(np.sin(u), np.sin(v))
z = center[2] + radius * np.outer(np.ones(np.size(u)), np.cos(v))

# Plotting the sphere
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(x, y, z, color='b', alpha=0.5)

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

plt.show()

#EX2
# First sphere: x^2 + y^2 + z^2 = 1
r1 = 1
x1 = r1 * np.outer(np.cos(u), np.sin(v))
y1 = r1 * np.outer(np.sin(u), np.sin(v))
z1 = r1 * np.outer(np.ones(np.size(u)), np.cos(v))

# Second sphere: x^2 + y^2 + z^2 = 2
r2 = np.sqrt(2)
x2 = r2 * np.outer(np.cos(u), np.sin(v))
y2 = r2 * np.outer(np.sin(u), np.sin(v))
z2 = r2 * np.outer(np.ones(np.size(u)), np.cos(v))

# Plotting both spheres
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

ax.plot_surface(x1, y1, z1, color='r', alpha=0.5)
ax.plot_surface(x2, y2, z2, color='g', alpha=0.5)

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

plt.show()

#EX3
# Define the sphere equations
def sphere1(x, y, z):
    return x**2 + y**2 + z**2 - 1

def sphere2(x, y, z):
    return (x - 1)**2 + y**2 + z**2 - 1

# Generate a meshgrid for visualization
x_vals = np.linspace(-1.5, 2, 100)
y_vals = np.linspace(-1.5, 1.5, 100)
X, Y = np.meshgrid(x_vals, y_vals)

# Solve for Z from both spheres
Z1 = np.sqrt(1 - X**2 - Y**2)  # From sphere1
Z2 = np.sqrt(1 - (X - 1)**2 - Y**2)  # From sphere2

# Plotting the intersection curve
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot the intersection
ax.plot_wireframe(X, Y, Z1, color='b', alpha=0.5)
ax.plot_wireframe(X, Y, -Z1, color='b', alpha=0.5)

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

plt.show()

#EX4
# Define the function for the paraboloid
def f(x, y):
    return (x - 1)**2 + y**2 + 1

# Gradient of the paraboloid
def grad_f(x, y):
    df_dx = 2 * (x - 1)
    df_dy = 2 * y
    return np.array([df_dx, df_dy])

# Point P
P = np.array([1, 0])

# Gradient at point P
grad_at_P = grad_f(P[0], P[1])

# Equation of the tangent plane: z - z_0 = grad_f(x_0, y_0) * (x - x_0, y - y_0)
# At point P (1, 0, 1), the equation becomes:
# z - 1 = grad_at_P[0] * (x - 1) + grad_at_P[1] * (y - 0)
# Rearranging: z = 1 + grad_at_P[0] * (x - 1) + grad_at_P[1] * (y - 0)

def tangent_plane(x, y):
    return 1 + grad_at_P[0] * (x - 1) + grad_at_P[1] * (y - 0)

# Create a meshgrid for plotting
x_vals = np.linspace(-2, 3, 100)
y_vals = np.linspace(-2, 3, 100)
X, Y = np.meshgrid(x_vals, y_vals)
Z = tangent_plane(X, Y)

# Plotting the paraboloid and the tangent plane
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot the paraboloid
Z_paraboloid = (X - 1)**2 + Y**2 + 1
ax.plot_surface(X, Y, Z_paraboloid, alpha=0.3, color='r')

# Plot the tangent plane
ax.plot_surface(X, Y, Z, alpha=0.5, color='g')

# Plot point P
ax.scatter(1, 0, 1, color='b', s=100)

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

plt.show()




